// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v3.21.12
// source: jwt.proto

package authv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ErrorCode - коды ошибок
type ErrorCode int32

const (
	ErrorCode_ERROR_UNKNOWN               ErrorCode = 0
	ErrorCode_ERROR_INVALID_TOKEN         ErrorCode = 1  // Токен невалиден (синтаксис, формат)
	ErrorCode_ERROR_EXPIRED_TOKEN         ErrorCode = 2  // Токен истек
	ErrorCode_ERROR_INVALID_SIGNATURE     ErrorCode = 3  // Неверная подпись
	ErrorCode_ERROR_TOKEN_REVOKED         ErrorCode = 4  // Токен отозван (в blacklist)
	ErrorCode_ERROR_INVALID_ISSUER        ErrorCode = 5  // Неверный issuer
	ErrorCode_ERROR_INVALID_AUDIENCE      ErrorCode = 6  // Неверный audience
	ErrorCode_ERROR_KEY_NOT_FOUND         ErrorCode = 7  // Ключ для проверки не найден
	ErrorCode_ERROR_INVALID_USER_ID       ErrorCode = 8  // Неверный user_id
	ErrorCode_ERROR_REFRESH_TOKEN_INVALID ErrorCode = 9  // Refresh token невалиден
	ErrorCode_ERROR_REFRESH_TOKEN_EXPIRED ErrorCode = 10 // Refresh token истек
	ErrorCode_ERROR_RATE_LIMIT_EXCEEDED   ErrorCode = 11 // Превышен лимит запросов
	ErrorCode_ERROR_UNAUTHENTICATED       ErrorCode = 12 // Отсутствует или невалидная аутентификация
	ErrorCode_ERROR_INVALID_PROJECT_ID    ErrorCode = 13 // Неверный или отсутствующий project_id
	ErrorCode_ERROR_INTERNAL              ErrorCode = 99 // Внутренняя ошибка сервиса
)

// Enum value maps for ErrorCode.
var (
	ErrorCode_name = map[int32]string{
		0:  "ERROR_UNKNOWN",
		1:  "ERROR_INVALID_TOKEN",
		2:  "ERROR_EXPIRED_TOKEN",
		3:  "ERROR_INVALID_SIGNATURE",
		4:  "ERROR_TOKEN_REVOKED",
		5:  "ERROR_INVALID_ISSUER",
		6:  "ERROR_INVALID_AUDIENCE",
		7:  "ERROR_KEY_NOT_FOUND",
		8:  "ERROR_INVALID_USER_ID",
		9:  "ERROR_REFRESH_TOKEN_INVALID",
		10: "ERROR_REFRESH_TOKEN_EXPIRED",
		11: "ERROR_RATE_LIMIT_EXCEEDED",
		12: "ERROR_UNAUTHENTICATED",
		13: "ERROR_INVALID_PROJECT_ID",
		99: "ERROR_INTERNAL",
	}
	ErrorCode_value = map[string]int32{
		"ERROR_UNKNOWN":               0,
		"ERROR_INVALID_TOKEN":         1,
		"ERROR_EXPIRED_TOKEN":         2,
		"ERROR_INVALID_SIGNATURE":     3,
		"ERROR_TOKEN_REVOKED":         4,
		"ERROR_INVALID_ISSUER":        5,
		"ERROR_INVALID_AUDIENCE":      6,
		"ERROR_KEY_NOT_FOUND":         7,
		"ERROR_INVALID_USER_ID":       8,
		"ERROR_REFRESH_TOKEN_INVALID": 9,
		"ERROR_REFRESH_TOKEN_EXPIRED": 10,
		"ERROR_RATE_LIMIT_EXCEEDED":   11,
		"ERROR_UNAUTHENTICATED":       12,
		"ERROR_INVALID_PROJECT_ID":    13,
		"ERROR_INTERNAL":              99,
	}
)

func (x ErrorCode) Enum() *ErrorCode {
	p := new(ErrorCode)
	*p = x
	return p
}

func (x ErrorCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ErrorCode) Descriptor() protoreflect.EnumDescriptor {
	return file_jwt_proto_enumTypes[0].Descriptor()
}

func (ErrorCode) Type() protoreflect.EnumType {
	return &file_jwt_proto_enumTypes[0]
}

func (x ErrorCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ErrorCode.Descriptor instead.
func (ErrorCode) EnumDescriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{0}
}

// IssueTokenRequest - запрос на выдачу токена
//
// Этот запрос создает JWT токен со следующей структурой:
// - Стандартные claims: sub (из user_id), iat, exp, iss, aud, jti (генерируются автоматически)
// - Обязательные custom claims: project_id (из project_id), type (из token_type или "access")
// - Опциональные custom claims: device_id (из device_id), + все из claims
//
// См. структуру токена: api/schemas/JWT_PAYLOAD_ACCESS.schema.json
type IssueTokenRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// User ID пользователя - попадет в JWT claim "sub"
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Дополнительные claims для включения в токен (например: roles, email, username)
	// Все значения должны быть строками
	// Эти claims будут добавлены в JWT токен "as is"
	// Пример: {"roles": "user,admin", "email": "user@example.com"}
	Claims map[string]string `protobuf:"bytes,2,rep,name=claims,proto3" json:"claims,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Время жизни access token (в секундах, по умолчанию из конфигурации проекта)
	AccessTokenTtl int64 `protobuf:"varint,3,opt,name=access_token_ttl,json=accessTokenTtl,proto3" json:"access_token_ttl,omitempty"`
	// Время жизни refresh token (в секундах, по умолчанию из конфигурации проекта)
	RefreshTokenTtl int64 `protobuf:"varint,4,opt,name=refresh_token_ttl,json=refreshTokenTtl,proto3" json:"refresh_token_ttl,omitempty"`
	// Идентификатор устройства - попадет в JWT claim "device_id" (опционально)
	DeviceId string `protobuf:"bytes,5,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	// Project ID (UUID) - попадет в JWT claim "project_id" (обязательно)
	// Если не указан в запросе, используется default_project_id из конфигурации
	ProjectId string `protobuf:"bytes,6,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Тип токена: "access", "refresh" (опционально)
	// Если не указан, выдаются оба токена (access + refresh)
	// Если указан "access" - только access token
	// Если указан "refresh" - только refresh token
	TokenType     string `protobuf:"bytes,7,opt,name=token_type,json=tokenType,proto3" json:"token_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IssueTokenRequest) Reset() {
	*x = IssueTokenRequest{}
	mi := &file_jwt_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueTokenRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueTokenRequest) ProtoMessage() {}

func (x *IssueTokenRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueTokenRequest.ProtoReflect.Descriptor instead.
func (*IssueTokenRequest) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{0}
}

func (x *IssueTokenRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *IssueTokenRequest) GetClaims() map[string]string {
	if x != nil {
		return x.Claims
	}
	return nil
}

func (x *IssueTokenRequest) GetAccessTokenTtl() int64 {
	if x != nil {
		return x.AccessTokenTtl
	}
	return 0
}

func (x *IssueTokenRequest) GetRefreshTokenTtl() int64 {
	if x != nil {
		return x.RefreshTokenTtl
	}
	return 0
}

func (x *IssueTokenRequest) GetDeviceId() string {
	if x != nil {
		return x.DeviceId
	}
	return ""
}

func (x *IssueTokenRequest) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *IssueTokenRequest) GetTokenType() string {
	if x != nil {
		return x.TokenType
	}
	return ""
}

// IssueTokenResponse - ответ с выданными токенами
type IssueTokenResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Access token (JWT)
	AccessToken string `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	// Refresh token (JWT)
	RefreshToken string `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
	// Время истечения access token (Unix timestamp)
	AccessTokenExpiresAt int64 `protobuf:"varint,3,opt,name=access_token_expires_at,json=accessTokenExpiresAt,proto3" json:"access_token_expires_at,omitempty"`
	// Время истечения refresh token (Unix timestamp)
	RefreshTokenExpiresAt int64 `protobuf:"varint,4,opt,name=refresh_token_expires_at,json=refreshTokenExpiresAt,proto3" json:"refresh_token_expires_at,omitempty"`
	// ID ключа, использованного для подписи
	KeyId string `protobuf:"bytes,5,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// TTL access token в секундах (время до истечения)
	ExpiresIn int64 `protobuf:"varint,6,opt,name=expires_in,json=expiresIn,proto3" json:"expires_in,omitempty"`
	// TTL refresh token в секундах (время до истечения)
	RefreshExpiresIn int64 `protobuf:"varint,7,opt,name=refresh_expires_in,json=refreshExpiresIn,proto3" json:"refresh_expires_in,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *IssueTokenResponse) Reset() {
	*x = IssueTokenResponse{}
	mi := &file_jwt_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueTokenResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueTokenResponse) ProtoMessage() {}

func (x *IssueTokenResponse) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueTokenResponse.ProtoReflect.Descriptor instead.
func (*IssueTokenResponse) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{1}
}

func (x *IssueTokenResponse) GetAccessToken() string {
	if x != nil {
		return x.AccessToken
	}
	return ""
}

func (x *IssueTokenResponse) GetRefreshToken() string {
	if x != nil {
		return x.RefreshToken
	}
	return ""
}

func (x *IssueTokenResponse) GetAccessTokenExpiresAt() int64 {
	if x != nil {
		return x.AccessTokenExpiresAt
	}
	return 0
}

func (x *IssueTokenResponse) GetRefreshTokenExpiresAt() int64 {
	if x != nil {
		return x.RefreshTokenExpiresAt
	}
	return 0
}

func (x *IssueTokenResponse) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

func (x *IssueTokenResponse) GetExpiresIn() int64 {
	if x != nil {
		return x.ExpiresIn
	}
	return 0
}

func (x *IssueTokenResponse) GetRefreshExpiresIn() int64 {
	if x != nil {
		return x.RefreshExpiresIn
	}
	return 0
}

// RefreshTokenRequest - запрос на обновление токена
// RefreshTokenRequest - запрос на обновление токена
//
// Использует refresh token для получения нового access token (и опционально нового refresh token).
// Refresh token должен быть валидным и не истекшим.
type RefreshTokenRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Refresh token - JWT токен типа "refresh"
	RefreshToken string `protobuf:"bytes,1,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
	// Идентификатор устройства (опционально)
	// Если указан, будет использован для нового access token вместо device_id из refresh token
	DeviceId string `protobuf:"bytes,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	// Project ID (UUID) - идентификатор проекта (обязательно для multi-project поддержки)
	// Должен совпадать с project_id в refresh token
	// Используется для валидации и получения конфигурации проекта
	ProjectId     string `protobuf:"bytes,3,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RefreshTokenRequest) Reset() {
	*x = RefreshTokenRequest{}
	mi := &file_jwt_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RefreshTokenRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RefreshTokenRequest) ProtoMessage() {}

func (x *RefreshTokenRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RefreshTokenRequest.ProtoReflect.Descriptor instead.
func (*RefreshTokenRequest) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{2}
}

func (x *RefreshTokenRequest) GetRefreshToken() string {
	if x != nil {
		return x.RefreshToken
	}
	return ""
}

func (x *RefreshTokenRequest) GetDeviceId() string {
	if x != nil {
		return x.DeviceId
	}
	return ""
}

func (x *RefreshTokenRequest) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

// RefreshTokenResponse - ответ с новыми токенами
type RefreshTokenResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Новый access token
	AccessToken string `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	// Новый refresh token (опционально, если включена ротация)
	RefreshToken string `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
	// Время истечения access token (Unix timestamp)
	AccessTokenExpiresAt int64 `protobuf:"varint,3,opt,name=access_token_expires_at,json=accessTokenExpiresAt,proto3" json:"access_token_expires_at,omitempty"`
	// Время истечения refresh token (Unix timestamp, если выдан новый)
	RefreshTokenExpiresAt int64 `protobuf:"varint,4,opt,name=refresh_token_expires_at,json=refreshTokenExpiresAt,proto3" json:"refresh_token_expires_at,omitempty"`
	// ID ключа, использованного для подписи
	KeyId string `protobuf:"bytes,5,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// TTL access token в секундах (время до истечения)
	ExpiresIn int64 `protobuf:"varint,6,opt,name=expires_in,json=expiresIn,proto3" json:"expires_in,omitempty"`
	// TTL refresh token в секундах (время до истечения)
	RefreshExpiresIn int64 `protobuf:"varint,7,opt,name=refresh_expires_in,json=refreshExpiresIn,proto3" json:"refresh_expires_in,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *RefreshTokenResponse) Reset() {
	*x = RefreshTokenResponse{}
	mi := &file_jwt_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RefreshTokenResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RefreshTokenResponse) ProtoMessage() {}

func (x *RefreshTokenResponse) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RefreshTokenResponse.ProtoReflect.Descriptor instead.
func (*RefreshTokenResponse) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{3}
}

func (x *RefreshTokenResponse) GetAccessToken() string {
	if x != nil {
		return x.AccessToken
	}
	return ""
}

func (x *RefreshTokenResponse) GetRefreshToken() string {
	if x != nil {
		return x.RefreshToken
	}
	return ""
}

func (x *RefreshTokenResponse) GetAccessTokenExpiresAt() int64 {
	if x != nil {
		return x.AccessTokenExpiresAt
	}
	return 0
}

func (x *RefreshTokenResponse) GetRefreshTokenExpiresAt() int64 {
	if x != nil {
		return x.RefreshTokenExpiresAt
	}
	return 0
}

func (x *RefreshTokenResponse) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

func (x *RefreshTokenResponse) GetExpiresIn() int64 {
	if x != nil {
		return x.ExpiresIn
	}
	return 0
}

func (x *RefreshTokenResponse) GetRefreshExpiresIn() int64 {
	if x != nil {
		return x.RefreshExpiresIn
	}
	return 0
}

// ValidateTokenRequest - запрос на валидацию токена
type ValidateTokenRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// JWT токен для валидации
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// Проверять ли blacklist (по умолчанию true)
	CheckBlacklist bool `protobuf:"varint,2,opt,name=check_blacklist,json=checkBlacklist,proto3" json:"check_blacklist,omitempty"`
	// Project ID (UUID) - идентификатор проекта (обязательно)
	ProjectId     string `protobuf:"bytes,3,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateTokenRequest) Reset() {
	*x = ValidateTokenRequest{}
	mi := &file_jwt_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateTokenRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateTokenRequest) ProtoMessage() {}

func (x *ValidateTokenRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateTokenRequest.ProtoReflect.Descriptor instead.
func (*ValidateTokenRequest) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{4}
}

func (x *ValidateTokenRequest) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *ValidateTokenRequest) GetCheckBlacklist() bool {
	if x != nil {
		return x.CheckBlacklist
	}
	return false
}

func (x *ValidateTokenRequest) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

// ValidateTokenResponse - результат валидации
type ValidateTokenResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Токен валиден
	Valid bool `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	// Причина невалидности (если valid = false)
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Код ошибки
	ErrorCode ErrorCode `protobuf:"varint,3,opt,name=error_code,json=errorCode,proto3,enum=auth.v1.ErrorCode" json:"error_code,omitempty"`
	// Claims из токена (если валиден)
	Claims        *TokenClaims `protobuf:"bytes,4,opt,name=claims,proto3" json:"claims,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateTokenResponse) Reset() {
	*x = ValidateTokenResponse{}
	mi := &file_jwt_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateTokenResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateTokenResponse) ProtoMessage() {}

func (x *ValidateTokenResponse) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateTokenResponse.ProtoReflect.Descriptor instead.
func (*ValidateTokenResponse) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{5}
}

func (x *ValidateTokenResponse) GetValid() bool {
	if x != nil {
		return x.Valid
	}
	return false
}

func (x *ValidateTokenResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *ValidateTokenResponse) GetErrorCode() ErrorCode {
	if x != nil {
		return x.ErrorCode
	}
	return ErrorCode_ERROR_UNKNOWN
}

func (x *ValidateTokenResponse) GetClaims() *TokenClaims {
	if x != nil {
		return x.Claims
	}
	return nil
}

// ParseTokenRequest - запрос на парсинг токена (без валидации)
type ParseTokenRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// JWT токен для парсинга
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// Project ID (UUID) - идентификатор проекта (обязательно)
	ProjectId     string `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ParseTokenRequest) Reset() {
	*x = ParseTokenRequest{}
	mi := &file_jwt_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ParseTokenRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ParseTokenRequest) ProtoMessage() {}

func (x *ParseTokenRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ParseTokenRequest.ProtoReflect.Descriptor instead.
func (*ParseTokenRequest) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{6}
}

func (x *ParseTokenRequest) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *ParseTokenRequest) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

// ParseTokenResponse - результат парсинга
type ParseTokenResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Успешно распарсен
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Ошибка парсинга (если success = false)
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Claims из токена
	Claims        *TokenClaims `protobuf:"bytes,3,opt,name=claims,proto3" json:"claims,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ParseTokenResponse) Reset() {
	*x = ParseTokenResponse{}
	mi := &file_jwt_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ParseTokenResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ParseTokenResponse) ProtoMessage() {}

func (x *ParseTokenResponse) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ParseTokenResponse.ProtoReflect.Descriptor instead.
func (*ParseTokenResponse) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{7}
}

func (x *ParseTokenResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ParseTokenResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *ParseTokenResponse) GetClaims() *TokenClaims {
	if x != nil {
		return x.Claims
	}
	return nil
}

// ExtractClaimsRequest - запрос на извлечение claims
type ExtractClaimsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// JWT токен
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// Список ключей claims для извлечения (пусто = все)
	ClaimKeys []string `protobuf:"bytes,2,rep,name=claim_keys,json=claimKeys,proto3" json:"claim_keys,omitempty"`
	// Project ID (UUID) - идентификатор проекта (обязательно)
	ProjectId     string `protobuf:"bytes,3,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExtractClaimsRequest) Reset() {
	*x = ExtractClaimsRequest{}
	mi := &file_jwt_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExtractClaimsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExtractClaimsRequest) ProtoMessage() {}

func (x *ExtractClaimsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExtractClaimsRequest.ProtoReflect.Descriptor instead.
func (*ExtractClaimsRequest) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{8}
}

func (x *ExtractClaimsRequest) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *ExtractClaimsRequest) GetClaimKeys() []string {
	if x != nil {
		return x.ClaimKeys
	}
	return nil
}

func (x *ExtractClaimsRequest) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

// ExtractClaimsResponse - извлеченные claims
type ExtractClaimsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Успешно извлечены
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Ошибка (если success = false)
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Извлеченные claims
	Claims        map[string]string `protobuf:"bytes,3,rep,name=claims,proto3" json:"claims,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExtractClaimsResponse) Reset() {
	*x = ExtractClaimsResponse{}
	mi := &file_jwt_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExtractClaimsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExtractClaimsResponse) ProtoMessage() {}

func (x *ExtractClaimsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExtractClaimsResponse.ProtoReflect.Descriptor instead.
func (*ExtractClaimsResponse) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{9}
}

func (x *ExtractClaimsResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ExtractClaimsResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *ExtractClaimsResponse) GetClaims() map[string]string {
	if x != nil {
		return x.Claims
	}
	return nil
}

// RevokeTokenRequest - запрос на отзыв токена
type RevokeTokenRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// JWT токен для отзыва
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// Время жизни в blacklist (в секундах, по умолчанию = TTL токена)
	Ttl int64 `protobuf:"varint,2,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// Project ID (UUID) - идентификатор проекта (обязательно)
	ProjectId     string `protobuf:"bytes,3,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RevokeTokenRequest) Reset() {
	*x = RevokeTokenRequest{}
	mi := &file_jwt_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RevokeTokenRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RevokeTokenRequest) ProtoMessage() {}

func (x *RevokeTokenRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RevokeTokenRequest.ProtoReflect.Descriptor instead.
func (*RevokeTokenRequest) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{10}
}

func (x *RevokeTokenRequest) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *RevokeTokenRequest) GetTtl() int64 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

func (x *RevokeTokenRequest) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

// RevokeTokenResponse - результат отзыва
type RevokeTokenResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Токен успешно отозван
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Ошибка (если success = false)
	Error         string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RevokeTokenResponse) Reset() {
	*x = RevokeTokenResponse{}
	mi := &file_jwt_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RevokeTokenResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RevokeTokenResponse) ProtoMessage() {}

func (x *RevokeTokenResponse) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RevokeTokenResponse.ProtoReflect.Descriptor instead.
func (*RevokeTokenResponse) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{11}
}

func (x *RevokeTokenResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *RevokeTokenResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// ValidateBatchRequest - запрос на пакетную валидацию
type ValidateBatchRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Список токенов для валидации
	Tokens []string `protobuf:"bytes,1,rep,name=tokens,proto3" json:"tokens,omitempty"`
	// Проверять ли blacklist
	CheckBlacklist bool `protobuf:"varint,2,opt,name=check_blacklist,json=checkBlacklist,proto3" json:"check_blacklist,omitempty"`
	// Project ID (UUID) - идентификатор проекта (обязательно)
	ProjectId     string `protobuf:"bytes,3,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateBatchRequest) Reset() {
	*x = ValidateBatchRequest{}
	mi := &file_jwt_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateBatchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateBatchRequest) ProtoMessage() {}

func (x *ValidateBatchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateBatchRequest.ProtoReflect.Descriptor instead.
func (*ValidateBatchRequest) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{12}
}

func (x *ValidateBatchRequest) GetTokens() []string {
	if x != nil {
		return x.Tokens
	}
	return nil
}

func (x *ValidateBatchRequest) GetCheckBlacklist() bool {
	if x != nil {
		return x.CheckBlacklist
	}
	return false
}

func (x *ValidateBatchRequest) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

// ValidateBatchResponse - результаты пакетной валидации
type ValidateBatchResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Результаты валидации для каждого токена (индекс соответствует индексу в запросе)
	Results       []*ValidateTokenResponse `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateBatchResponse) Reset() {
	*x = ValidateBatchResponse{}
	mi := &file_jwt_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateBatchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateBatchResponse) ProtoMessage() {}

func (x *ValidateBatchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateBatchResponse.ProtoReflect.Descriptor instead.
func (*ValidateBatchResponse) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{13}
}

func (x *ValidateBatchResponse) GetResults() []*ValidateTokenResponse {
	if x != nil {
		return x.Results
	}
	return nil
}

// TokenClaims - структура claims, возвращаемая из ValidateToken и ParseToken
//
// ВАЖНО: Эта структура описывает API ответ, а НЕ структуру JWT токена!
// Реальная структура JWT токена описана в api/schemas/JWT_PAYLOAD.schema.json
//
// В JWT токене claims имеют следующую структуру:
// - Стандартные JWT claims: sub, iat, exp, iss, aud, jti
// - Обязательные custom claims: project_id, type
// - Опциональные custom claims: device_id, roles, source_service, target_service, etc.
//
// См. полную спецификацию:
// - JSON Schema: api/schemas/JWT_PAYLOAD.schema.json
// - Документация: docs/JWT_CLAIMS.md
type TokenClaims struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Стандартные JWT claims
	// User ID - из JWT claim "sub"
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Issued at - из JWT claim "iat" (Unix timestamp)
	IssuedAt int64 `protobuf:"varint,2,opt,name=issued_at,json=issuedAt,proto3" json:"issued_at,omitempty"`
	// Expires at - из JWT claim "exp" (Unix timestamp)
	ExpiresAt int64 `protobuf:"varint,3,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	// Issuer - из JWT claim "iss"
	Issuer string `protobuf:"bytes,4,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// Audience - из JWT claim "aud"
	Audience string `protobuf:"bytes,5,opt,name=audience,proto3" json:"audience,omitempty"`
	// JWT ID - из JWT claim "jti"
	JwtId string `protobuf:"bytes,6,opt,name=jwt_id,json=jwtId,proto3" json:"jwt_id,omitempty"`
	// Обязательные custom claims
	// Тип токена - из JWT claim "type" ("access", "refresh", "inter_service")
	TokenType string `protobuf:"bytes,7,opt,name=token_type,json=tokenType,proto3" json:"token_type,omitempty"`
	// Project ID - из JWT claim "project_id" (UUID, обязателен во всех токенах)
	ProjectId string `protobuf:"bytes,8,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Опциональные стандартные custom claims (для быстрого доступа)
	// ID ключа - из JWT claim "key_id" (для ротации ключей)
	KeyId string `protobuf:"bytes,9,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// Device ID - из JWT claim "device_id" (для отслеживания сессий)
	DeviceId string `protobuf:"bytes,10,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	// Roles - из JWT claim "roles" (comma-separated string, например "user,admin")
	Roles string `protobuf:"bytes,11,opt,name=roles,proto3" json:"roles,omitempty"`
	// Email - из JWT claim "email" (email пользователя)
	Email string `protobuf:"bytes,12,opt,name=email,proto3" json:"email,omitempty"`
	// Username - из JWT claim "username" (отображаемое имя пользователя)
	Username string `protobuf:"bytes,13,opt,name=username,proto3" json:"username,omitempty"`
	// Source Service - из JWT claim "source_service" (для inter_service токенов)
	SourceService string `protobuf:"bytes,14,opt,name=source_service,json=sourceService,proto3" json:"source_service,omitempty"`
	// Target Service - из JWT claim "target_service" (для inter_service токенов)
	TargetService string `protobuf:"bytes,15,opt,name=target_service,json=targetService,proto3" json:"target_service,omitempty"`
	// User ID in context - из JWT claim "user_id" (для service токенов с user context)
	UserIdInContext string `protobuf:"bytes,16,opt,name=user_id_in_context,json=userIdInContext,proto3" json:"user_id_in_context,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TokenClaims) Reset() {
	*x = TokenClaims{}
	mi := &file_jwt_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenClaims) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenClaims) ProtoMessage() {}

func (x *TokenClaims) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenClaims.ProtoReflect.Descriptor instead.
func (*TokenClaims) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{14}
}

func (x *TokenClaims) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *TokenClaims) GetIssuedAt() int64 {
	if x != nil {
		return x.IssuedAt
	}
	return 0
}

func (x *TokenClaims) GetExpiresAt() int64 {
	if x != nil {
		return x.ExpiresAt
	}
	return 0
}

func (x *TokenClaims) GetIssuer() string {
	if x != nil {
		return x.Issuer
	}
	return ""
}

func (x *TokenClaims) GetAudience() string {
	if x != nil {
		return x.Audience
	}
	return ""
}

func (x *TokenClaims) GetJwtId() string {
	if x != nil {
		return x.JwtId
	}
	return ""
}

func (x *TokenClaims) GetTokenType() string {
	if x != nil {
		return x.TokenType
	}
	return ""
}

func (x *TokenClaims) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *TokenClaims) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

func (x *TokenClaims) GetDeviceId() string {
	if x != nil {
		return x.DeviceId
	}
	return ""
}

func (x *TokenClaims) GetRoles() string {
	if x != nil {
		return x.Roles
	}
	return ""
}

func (x *TokenClaims) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *TokenClaims) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *TokenClaims) GetSourceService() string {
	if x != nil {
		return x.SourceService
	}
	return ""
}

func (x *TokenClaims) GetTargetService() string {
	if x != nil {
		return x.TargetService
	}
	return ""
}

func (x *TokenClaims) GetUserIdInContext() string {
	if x != nil {
		return x.UserIdInContext
	}
	return ""
}

// GetPublicKeyRequest - запрос на получение публичного ключа
type GetPublicKeyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Project ID (UUID) - идентификатор проекта
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Key ID - идентификатор конкретного ключа (опционально)
	// Если не указан, возвращается текущий активный ключ для проекта
	KeyId         string `protobuf:"bytes,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPublicKeyRequest) Reset() {
	*x = GetPublicKeyRequest{}
	mi := &file_jwt_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPublicKeyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPublicKeyRequest) ProtoMessage() {}

func (x *GetPublicKeyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPublicKeyRequest.ProtoReflect.Descriptor instead.
func (*GetPublicKeyRequest) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{15}
}

func (x *GetPublicKeyRequest) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *GetPublicKeyRequest) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

// GetPublicKeyResponse - ответ с публичным ключом
type GetPublicKeyResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Публичный ключ в формате PEM (для RSA, ECDSA, Ed25519)
	// Для HMAC возвращается пустая строка (HMAC не использует публичные ключи)
	// Это основной (primary) ключ для подписи
	PublicKeyPem string `protobuf:"bytes,1,opt,name=public_key_pem,json=publicKeyPem,proto3" json:"public_key_pem,omitempty"`
	// Алгоритм (RS256, RS384, RS512, ES256, ES384, ES512, EdDSA, HS256, HS384, HS512)
	Algorithm string `protobuf:"bytes,2,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	// Key ID - идентификатор ключа
	KeyId string `protobuf:"bytes,3,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// Project ID
	ProjectId string `protobuf:"bytes,4,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Время истечения кэша (Unix timestamp)
	// Рекомендуется кэшировать ключ до этого времени
	// При ротации ключей это время обновляется
	CacheUntil int64 `protobuf:"varint,5,opt,name=cache_until,json=cacheUntil,proto3" json:"cache_until,omitempty"`
	// Список всех активных ключей (для graceful ротации)
	// Клиенты должны кэшировать все активные ключи для валидации токенов,
	// подписанных как старыми, так и новыми ключами во время ротации
	ActiveKeys    []*PublicKeyInfo `protobuf:"bytes,6,rep,name=active_keys,json=activeKeys,proto3" json:"active_keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPublicKeyResponse) Reset() {
	*x = GetPublicKeyResponse{}
	mi := &file_jwt_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPublicKeyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPublicKeyResponse) ProtoMessage() {}

func (x *GetPublicKeyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPublicKeyResponse.ProtoReflect.Descriptor instead.
func (*GetPublicKeyResponse) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{16}
}

func (x *GetPublicKeyResponse) GetPublicKeyPem() string {
	if x != nil {
		return x.PublicKeyPem
	}
	return ""
}

func (x *GetPublicKeyResponse) GetAlgorithm() string {
	if x != nil {
		return x.Algorithm
	}
	return ""
}

func (x *GetPublicKeyResponse) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

func (x *GetPublicKeyResponse) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *GetPublicKeyResponse) GetCacheUntil() int64 {
	if x != nil {
		return x.CacheUntil
	}
	return 0
}

func (x *GetPublicKeyResponse) GetActiveKeys() []*PublicKeyInfo {
	if x != nil {
		return x.ActiveKeys
	}
	return nil
}

// PublicKeyInfo - информация об активном публичном ключе
type PublicKeyInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Key ID - идентификатор ключа
	KeyId string `protobuf:"bytes,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// Публичный ключ в формате PEM
	PublicKeyPem string `protobuf:"bytes,2,opt,name=public_key_pem,json=publicKeyPem,proto3" json:"public_key_pem,omitempty"`
	// Алгоритм
	Algorithm string `protobuf:"bytes,3,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	// Время истечения активности ключа (Unix timestamp)
	// После этого времени ключ станет неактивным и не будет использоваться для подписи
	// Токены, подписанные этим ключом, останутся валидными до своего exp
	ExpiresAt int64 `protobuf:"varint,4,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	// Основной ключ для подписи (true) или старый ключ в процессе ротации (false)
	IsPrimary     bool `protobuf:"varint,5,opt,name=is_primary,json=isPrimary,proto3" json:"is_primary,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublicKeyInfo) Reset() {
	*x = PublicKeyInfo{}
	mi := &file_jwt_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublicKeyInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublicKeyInfo) ProtoMessage() {}

func (x *PublicKeyInfo) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublicKeyInfo.ProtoReflect.Descriptor instead.
func (*PublicKeyInfo) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{17}
}

func (x *PublicKeyInfo) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

func (x *PublicKeyInfo) GetPublicKeyPem() string {
	if x != nil {
		return x.PublicKeyPem
	}
	return ""
}

func (x *PublicKeyInfo) GetAlgorithm() string {
	if x != nil {
		return x.Algorithm
	}
	return ""
}

func (x *PublicKeyInfo) GetExpiresAt() int64 {
	if x != nil {
		return x.ExpiresAt
	}
	return 0
}

func (x *PublicKeyInfo) GetIsPrimary() bool {
	if x != nil {
		return x.IsPrimary
	}
	return false
}

// HealthCheckRequest - запрос на проверку здоровья
type HealthCheckRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthCheckRequest) Reset() {
	*x = HealthCheckRequest{}
	mi := &file_jwt_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheckRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheckRequest) ProtoMessage() {}

func (x *HealthCheckRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheckRequest.ProtoReflect.Descriptor instead.
func (*HealthCheckRequest) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{18}
}

// HealthCheckResponse - ответ о состоянии сервиса
// Формат согласован с JSON Schema: status enum, timestamp, details
type HealthCheckResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Статус сервиса: "healthy", "degraded", "unhealthy"
	Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// Timestamp проверки (Unix timestamp)
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Детали состояния (опционально)
	// Содержит информацию о подсистемах: redis, keys, etc.
	Details map[string]string `protobuf:"bytes,3,rep,name=details,proto3" json:"details,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Версия сервиса
	Version string `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	// Время работы сервиса (uptime в секундах)
	Uptime        int64 `protobuf:"varint,5,opt,name=uptime,proto3" json:"uptime,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthCheckResponse) Reset() {
	*x = HealthCheckResponse{}
	mi := &file_jwt_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheckResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheckResponse) ProtoMessage() {}

func (x *HealthCheckResponse) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheckResponse.ProtoReflect.Descriptor instead.
func (*HealthCheckResponse) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{19}
}

func (x *HealthCheckResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *HealthCheckResponse) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *HealthCheckResponse) GetDetails() map[string]string {
	if x != nil {
		return x.Details
	}
	return nil
}

func (x *HealthCheckResponse) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *HealthCheckResponse) GetUptime() int64 {
	if x != nil {
		return x.Uptime
	}
	return 0
}

// IssueServiceTokenRequest - запрос на выдачу межсервисного токена
// IssueServiceTokenRequest - запрос на выдачу межсервисного токена
//
// Этот запрос создает JWT токен со следующей структурой:
// - Стандартные claims: sub (из source_service), iat, exp, iss, aud, jti (генерируются автоматически)
// - Обязательные custom claims: project_id (из project_id), type ("inter_service"), source_service (из source_service)
// - Опциональные custom claims: target_service (из target_service), user_id (из user_id), + все из claims
//
// См. структуру токена: api/schemas/JWT_PAYLOAD_SERVICE.schema.json
type IssueServiceTokenRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Source service - сервис, который запрашивает токен (обязательно)
	// Попадет в JWT claim "source_service" и "sub"
	// Валидация: должен быть непустой, должен соответствовать service_auth.secrets в конфигурации
	SourceService string `protobuf:"bytes,1,opt,name=source_service,json=sourceService,proto3" json:"source_service,omitempty"`
	// Target service - сервис, для которого предназначен токен (опционально)
	// Попадет в JWT claim "target_service"
	// Если не указан, токен может использоваться для всех сервисов
	// Если указан, может использоваться для валидации на стороне получателя
	TargetService string `protobuf:"bytes,2,opt,name=target_service,json=targetService,proto3" json:"target_service,omitempty"`
	// User ID - идентификатор пользователя (опционально для межсервисных токенов)
	// Попадет в JWT claim "user_id" (не "sub"!)
	// Используется для service токенов, привязанных к пользовательскому контексту
	// Например, когда Gateway перевыпускает user token как service token
	UserId string `protobuf:"bytes,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Дополнительные claims для включения в токен (например: roles, email, username)
	// Все значения должны быть строками
	// Эти claims будут добавлены в JWT токен "as is"
	// Пример: {"roles": "user,admin", "email": "user@example.com"}
	Claims map[string]string `protobuf:"bytes,4,rep,name=claims,proto3" json:"claims,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Время жизни токена (в секундах, по умолчанию из конфигурации проекта для межсервисных токенов)
	Ttl int64 `protobuf:"varint,5,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// Project ID (UUID) - попадет в JWT claim "project_id" (обязательно)
	// Если не указан в запросе, используется default_project_id из конфигурации
	ProjectId     string `protobuf:"bytes,6,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IssueServiceTokenRequest) Reset() {
	*x = IssueServiceTokenRequest{}
	mi := &file_jwt_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueServiceTokenRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueServiceTokenRequest) ProtoMessage() {}

func (x *IssueServiceTokenRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueServiceTokenRequest.ProtoReflect.Descriptor instead.
func (*IssueServiceTokenRequest) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{20}
}

func (x *IssueServiceTokenRequest) GetSourceService() string {
	if x != nil {
		return x.SourceService
	}
	return ""
}

func (x *IssueServiceTokenRequest) GetTargetService() string {
	if x != nil {
		return x.TargetService
	}
	return ""
}

func (x *IssueServiceTokenRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *IssueServiceTokenRequest) GetClaims() map[string]string {
	if x != nil {
		return x.Claims
	}
	return nil
}

func (x *IssueServiceTokenRequest) GetTtl() int64 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

func (x *IssueServiceTokenRequest) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

// CreateAPIKeyRequest - запрос на создание API ключа
type CreateAPIKeyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Project ID (UUID) - идентификатор проекта
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// User ID - пользователь, которому принадлежит ключ (опционально)
	UserId string `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Название/описание ключа (для идентификации)
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Список разрешений (scopes) для ключа
	Scopes []string `protobuf:"bytes,4,rep,name=scopes,proto3" json:"scopes,omitempty"`
	// Время жизни ключа (в секундах, 0 = без ограничения)
	Ttl int64 `protobuf:"varint,5,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// IP-адреса, с которых разрешено использование ключа (опционально)
	AllowedIps    []string `protobuf:"bytes,6,rep,name=allowed_ips,json=allowedIps,proto3" json:"allowed_ips,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateAPIKeyRequest) Reset() {
	*x = CreateAPIKeyRequest{}
	mi := &file_jwt_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateAPIKeyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateAPIKeyRequest) ProtoMessage() {}

func (x *CreateAPIKeyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateAPIKeyRequest.ProtoReflect.Descriptor instead.
func (*CreateAPIKeyRequest) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{21}
}

func (x *CreateAPIKeyRequest) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *CreateAPIKeyRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *CreateAPIKeyRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateAPIKeyRequest) GetScopes() []string {
	if x != nil {
		return x.Scopes
	}
	return nil
}

func (x *CreateAPIKeyRequest) GetTtl() int64 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

func (x *CreateAPIKeyRequest) GetAllowedIps() []string {
	if x != nil {
		return x.AllowedIps
	}
	return nil
}

// CreateAPIKeyResponse - ответ с созданным API ключом
type CreateAPIKeyResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// API ключ (возвращается только один раз при создании)
	ApiKey string `protobuf:"bytes,1,opt,name=api_key,json=apiKey,proto3" json:"api_key,omitempty"`
	// ID ключа (для последующего управления)
	KeyId string `protobuf:"bytes,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// Время истечения ключа (Unix timestamp, 0 = без ограничения)
	ExpiresAt int64 `protobuf:"varint,3,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	// Дата создания (Unix timestamp)
	CreatedAt     int64 `protobuf:"varint,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateAPIKeyResponse) Reset() {
	*x = CreateAPIKeyResponse{}
	mi := &file_jwt_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateAPIKeyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateAPIKeyResponse) ProtoMessage() {}

func (x *CreateAPIKeyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateAPIKeyResponse.ProtoReflect.Descriptor instead.
func (*CreateAPIKeyResponse) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{22}
}

func (x *CreateAPIKeyResponse) GetApiKey() string {
	if x != nil {
		return x.ApiKey
	}
	return ""
}

func (x *CreateAPIKeyResponse) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

func (x *CreateAPIKeyResponse) GetExpiresAt() int64 {
	if x != nil {
		return x.ExpiresAt
	}
	return 0
}

func (x *CreateAPIKeyResponse) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

// ValidateAPIKeyRequest - запрос на валидацию API ключа
type ValidateAPIKeyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// API ключ для валидации
	ApiKey string `protobuf:"bytes,1,opt,name=api_key,json=apiKey,proto3" json:"api_key,omitempty"`
	// Требуемые разрешения (scopes) - опционально
	RequiredScopes []string `protobuf:"bytes,2,rep,name=required_scopes,json=requiredScopes,proto3" json:"required_scopes,omitempty"`
	// Project ID (UUID) - идентификатор проекта (обязательно)
	ProjectId     string `protobuf:"bytes,3,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateAPIKeyRequest) Reset() {
	*x = ValidateAPIKeyRequest{}
	mi := &file_jwt_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateAPIKeyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateAPIKeyRequest) ProtoMessage() {}

func (x *ValidateAPIKeyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateAPIKeyRequest.ProtoReflect.Descriptor instead.
func (*ValidateAPIKeyRequest) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{23}
}

func (x *ValidateAPIKeyRequest) GetApiKey() string {
	if x != nil {
		return x.ApiKey
	}
	return ""
}

func (x *ValidateAPIKeyRequest) GetRequiredScopes() []string {
	if x != nil {
		return x.RequiredScopes
	}
	return nil
}

func (x *ValidateAPIKeyRequest) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

// ValidateAPIKeyResponse - результат валидации API ключа
type ValidateAPIKeyResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Ключ валиден
	Valid bool `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	// Причина невалидности (если valid = false)
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Код ошибки
	ErrorCode ErrorCode `protobuf:"varint,3,opt,name=error_code,json=errorCode,proto3,enum=auth.v1.ErrorCode" json:"error_code,omitempty"`
	// Project ID
	ProjectId string `protobuf:"bytes,4,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// User ID (если ключ привязан к пользователю)
	UserId string `protobuf:"bytes,5,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Разрешения (scopes) ключа
	Scopes []string `protobuf:"bytes,6,rep,name=scopes,proto3" json:"scopes,omitempty"`
	// Метаданные ключа
	Metadata      map[string]string `protobuf:"bytes,7,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateAPIKeyResponse) Reset() {
	*x = ValidateAPIKeyResponse{}
	mi := &file_jwt_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateAPIKeyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateAPIKeyResponse) ProtoMessage() {}

func (x *ValidateAPIKeyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateAPIKeyResponse.ProtoReflect.Descriptor instead.
func (*ValidateAPIKeyResponse) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{24}
}

func (x *ValidateAPIKeyResponse) GetValid() bool {
	if x != nil {
		return x.Valid
	}
	return false
}

func (x *ValidateAPIKeyResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *ValidateAPIKeyResponse) GetErrorCode() ErrorCode {
	if x != nil {
		return x.ErrorCode
	}
	return ErrorCode_ERROR_UNKNOWN
}

func (x *ValidateAPIKeyResponse) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *ValidateAPIKeyResponse) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *ValidateAPIKeyResponse) GetScopes() []string {
	if x != nil {
		return x.Scopes
	}
	return nil
}

func (x *ValidateAPIKeyResponse) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// RevokeAPIKeyRequest - запрос на отзыв API ключа
type RevokeAPIKeyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ID ключа для отзыва
	KeyId string `protobuf:"bytes,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// Или API ключ напрямую
	ApiKey string `protobuf:"bytes,2,opt,name=api_key,json=apiKey,proto3" json:"api_key,omitempty"`
	// Project ID (для проверки прав)
	ProjectId     string `protobuf:"bytes,3,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RevokeAPIKeyRequest) Reset() {
	*x = RevokeAPIKeyRequest{}
	mi := &file_jwt_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RevokeAPIKeyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RevokeAPIKeyRequest) ProtoMessage() {}

func (x *RevokeAPIKeyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RevokeAPIKeyRequest.ProtoReflect.Descriptor instead.
func (*RevokeAPIKeyRequest) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{25}
}

func (x *RevokeAPIKeyRequest) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

func (x *RevokeAPIKeyRequest) GetApiKey() string {
	if x != nil {
		return x.ApiKey
	}
	return ""
}

func (x *RevokeAPIKeyRequest) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

// RevokeAPIKeyResponse - результат отзыва API ключа
type RevokeAPIKeyResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Ключ успешно отозван
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Ошибка (если success = false)
	Error         string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RevokeAPIKeyResponse) Reset() {
	*x = RevokeAPIKeyResponse{}
	mi := &file_jwt_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RevokeAPIKeyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RevokeAPIKeyResponse) ProtoMessage() {}

func (x *RevokeAPIKeyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RevokeAPIKeyResponse.ProtoReflect.Descriptor instead.
func (*RevokeAPIKeyResponse) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{26}
}

func (x *RevokeAPIKeyResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *RevokeAPIKeyResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// ListAPIKeysRequest - запрос на получение списка API ключей
type ListAPIKeysRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Project ID (UUID) - идентификатор проекта
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// User ID - фильтр по пользователю (опционально)
	UserId string `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Пагинация: номер страницы (начиная с 1)
	Page int32 `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
	// Пагинация: размер страницы
	PageSize      int32 `protobuf:"varint,4,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListAPIKeysRequest) Reset() {
	*x = ListAPIKeysRequest{}
	mi := &file_jwt_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListAPIKeysRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListAPIKeysRequest) ProtoMessage() {}

func (x *ListAPIKeysRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListAPIKeysRequest.ProtoReflect.Descriptor instead.
func (*ListAPIKeysRequest) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{27}
}

func (x *ListAPIKeysRequest) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *ListAPIKeysRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *ListAPIKeysRequest) GetPage() int32 {
	if x != nil {
		return x.Page
	}
	return 0
}

func (x *ListAPIKeysRequest) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

// ListAPIKeysResponse - список API ключей
type ListAPIKeysResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Список ключей (без самого ключа, только метаданные)
	Keys []*APIKeyInfo `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	// Общее количество ключей
	Total int32 `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	// Номер текущей страницы
	Page int32 `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
	// Размер страницы
	PageSize      int32 `protobuf:"varint,4,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListAPIKeysResponse) Reset() {
	*x = ListAPIKeysResponse{}
	mi := &file_jwt_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListAPIKeysResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListAPIKeysResponse) ProtoMessage() {}

func (x *ListAPIKeysResponse) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListAPIKeysResponse.ProtoReflect.Descriptor instead.
func (*ListAPIKeysResponse) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{28}
}

func (x *ListAPIKeysResponse) GetKeys() []*APIKeyInfo {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *ListAPIKeysResponse) GetTotal() int32 {
	if x != nil {
		return x.Total
	}
	return 0
}

func (x *ListAPIKeysResponse) GetPage() int32 {
	if x != nil {
		return x.Page
	}
	return 0
}

func (x *ListAPIKeysResponse) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

// APIKeyInfo - информация об API ключе (без самого ключа)
type APIKeyInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ID ключа
	KeyId string `protobuf:"bytes,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// Название/описание
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Project ID
	ProjectId string `protobuf:"bytes,3,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// User ID (если привязан)
	UserId string `protobuf:"bytes,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Разрешения (scopes)
	Scopes []string `protobuf:"bytes,5,rep,name=scopes,proto3" json:"scopes,omitempty"`
	// Дата создания (Unix timestamp)
	CreatedAt int64 `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Время истечения (Unix timestamp, 0 = без ограничения)
	ExpiresAt int64 `protobuf:"varint,7,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	// Активен ли ключ
	Active bool `protobuf:"varint,8,opt,name=active,proto3" json:"active,omitempty"`
	// Последнее использование (Unix timestamp)
	LastUsedAt    int64 `protobuf:"varint,9,opt,name=last_used_at,json=lastUsedAt,proto3" json:"last_used_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *APIKeyInfo) Reset() {
	*x = APIKeyInfo{}
	mi := &file_jwt_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *APIKeyInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*APIKeyInfo) ProtoMessage() {}

func (x *APIKeyInfo) ProtoReflect() protoreflect.Message {
	mi := &file_jwt_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use APIKeyInfo.ProtoReflect.Descriptor instead.
func (*APIKeyInfo) Descriptor() ([]byte, []int) {
	return file_jwt_proto_rawDescGZIP(), []int{29}
}

func (x *APIKeyInfo) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

func (x *APIKeyInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *APIKeyInfo) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *APIKeyInfo) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *APIKeyInfo) GetScopes() []string {
	if x != nil {
		return x.Scopes
	}
	return nil
}

func (x *APIKeyInfo) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *APIKeyInfo) GetExpiresAt() int64 {
	if x != nil {
		return x.ExpiresAt
	}
	return 0
}

func (x *APIKeyInfo) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

func (x *APIKeyInfo) GetLastUsedAt() int64 {
	if x != nil {
		return x.LastUsedAt
	}
	return 0
}

var File_jwt_proto protoreflect.FileDescriptor

const file_jwt_proto_rawDesc = "" +
	"\n" +
	"\tjwt.proto\x12\aauth.v1\"\xd8\x02\n" +
	"\x11IssueTokenRequest\x12\x17\n" +
	"\auser_id\x18\x01 \x01(\tR\x06userId\x12>\n" +
	"\x06claims\x18\x02 \x03(\v2&.auth.v1.IssueTokenRequest.ClaimsEntryR\x06claims\x12(\n" +
	"\x10access_token_ttl\x18\x03 \x01(\x03R\x0eaccessTokenTtl\x12*\n" +
	"\x11refresh_token_ttl\x18\x04 \x01(\x03R\x0frefreshTokenTtl\x12\x1b\n" +
	"\tdevice_id\x18\x05 \x01(\tR\bdeviceId\x12\x1d\n" +
	"\n" +
	"project_id\x18\x06 \x01(\tR\tprojectId\x12\x1d\n" +
	"\n" +
	"token_type\x18\a \x01(\tR\ttokenType\x1a9\n" +
	"\vClaimsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xb0\x02\n" +
	"\x12IssueTokenResponse\x12!\n" +
	"\faccess_token\x18\x01 \x01(\tR\vaccessToken\x12#\n" +
	"\rrefresh_token\x18\x02 \x01(\tR\frefreshToken\x125\n" +
	"\x17access_token_expires_at\x18\x03 \x01(\x03R\x14accessTokenExpiresAt\x127\n" +
	"\x18refresh_token_expires_at\x18\x04 \x01(\x03R\x15refreshTokenExpiresAt\x12\x15\n" +
	"\x06key_id\x18\x05 \x01(\tR\x05keyId\x12\x1d\n" +
	"\n" +
	"expires_in\x18\x06 \x01(\x03R\texpiresIn\x12,\n" +
	"\x12refresh_expires_in\x18\a \x01(\x03R\x10refreshExpiresIn\"v\n" +
	"\x13RefreshTokenRequest\x12#\n" +
	"\rrefresh_token\x18\x01 \x01(\tR\frefreshToken\x12\x1b\n" +
	"\tdevice_id\x18\x02 \x01(\tR\bdeviceId\x12\x1d\n" +
	"\n" +
	"project_id\x18\x03 \x01(\tR\tprojectId\"\xb2\x02\n" +
	"\x14RefreshTokenResponse\x12!\n" +
	"\faccess_token\x18\x01 \x01(\tR\vaccessToken\x12#\n" +
	"\rrefresh_token\x18\x02 \x01(\tR\frefreshToken\x125\n" +
	"\x17access_token_expires_at\x18\x03 \x01(\x03R\x14accessTokenExpiresAt\x127\n" +
	"\x18refresh_token_expires_at\x18\x04 \x01(\x03R\x15refreshTokenExpiresAt\x12\x15\n" +
	"\x06key_id\x18\x05 \x01(\tR\x05keyId\x12\x1d\n" +
	"\n" +
	"expires_in\x18\x06 \x01(\x03R\texpiresIn\x12,\n" +
	"\x12refresh_expires_in\x18\a \x01(\x03R\x10refreshExpiresIn\"t\n" +
	"\x14ValidateTokenRequest\x12\x14\n" +
	"\x05token\x18\x01 \x01(\tR\x05token\x12'\n" +
	"\x0fcheck_blacklist\x18\x02 \x01(\bR\x0echeckBlacklist\x12\x1d\n" +
	"\n" +
	"project_id\x18\x03 \x01(\tR\tprojectId\"\xa4\x01\n" +
	"\x15ValidateTokenResponse\x12\x14\n" +
	"\x05valid\x18\x01 \x01(\bR\x05valid\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x121\n" +
	"\n" +
	"error_code\x18\x03 \x01(\x0e2\x12.auth.v1.ErrorCodeR\terrorCode\x12,\n" +
	"\x06claims\x18\x04 \x01(\v2\x14.auth.v1.TokenClaimsR\x06claims\"H\n" +
	"\x11ParseTokenRequest\x12\x14\n" +
	"\x05token\x18\x01 \x01(\tR\x05token\x12\x1d\n" +
	"\n" +
	"project_id\x18\x02 \x01(\tR\tprojectId\"r\n" +
	"\x12ParseTokenResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12,\n" +
	"\x06claims\x18\x03 \x01(\v2\x14.auth.v1.TokenClaimsR\x06claims\"j\n" +
	"\x14ExtractClaimsRequest\x12\x14\n" +
	"\x05token\x18\x01 \x01(\tR\x05token\x12\x1d\n" +
	"\n" +
	"claim_keys\x18\x02 \x03(\tR\tclaimKeys\x12\x1d\n" +
	"\n" +
	"project_id\x18\x03 \x01(\tR\tprojectId\"\xc6\x01\n" +
	"\x15ExtractClaimsResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12B\n" +
	"\x06claims\x18\x03 \x03(\v2*.auth.v1.ExtractClaimsResponse.ClaimsEntryR\x06claims\x1a9\n" +
	"\vClaimsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"[\n" +
	"\x12RevokeTokenRequest\x12\x14\n" +
	"\x05token\x18\x01 \x01(\tR\x05token\x12\x10\n" +
	"\x03ttl\x18\x02 \x01(\x03R\x03ttl\x12\x1d\n" +
	"\n" +
	"project_id\x18\x03 \x01(\tR\tprojectId\"E\n" +
	"\x13RevokeTokenResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"v\n" +
	"\x14ValidateBatchRequest\x12\x16\n" +
	"\x06tokens\x18\x01 \x03(\tR\x06tokens\x12'\n" +
	"\x0fcheck_blacklist\x18\x02 \x01(\bR\x0echeckBlacklist\x12\x1d\n" +
	"\n" +
	"project_id\x18\x03 \x01(\tR\tprojectId\"Q\n" +
	"\x15ValidateBatchResponse\x128\n" +
	"\aresults\x18\x01 \x03(\v2\x1e.auth.v1.ValidateTokenResponseR\aresults\"\xe2\x03\n" +
	"\vTokenClaims\x12\x17\n" +
	"\auser_id\x18\x01 \x01(\tR\x06userId\x12\x1b\n" +
	"\tissued_at\x18\x02 \x01(\x03R\bissuedAt\x12\x1d\n" +
	"\n" +
	"expires_at\x18\x03 \x01(\x03R\texpiresAt\x12\x16\n" +
	"\x06issuer\x18\x04 \x01(\tR\x06issuer\x12\x1a\n" +
	"\baudience\x18\x05 \x01(\tR\baudience\x12\x15\n" +
	"\x06jwt_id\x18\x06 \x01(\tR\x05jwtId\x12\x1d\n" +
	"\n" +
	"token_type\x18\a \x01(\tR\ttokenType\x12\x1d\n" +
	"\n" +
	"project_id\x18\b \x01(\tR\tprojectId\x12\x15\n" +
	"\x06key_id\x18\t \x01(\tR\x05keyId\x12\x1b\n" +
	"\tdevice_id\x18\n" +
	" \x01(\tR\bdeviceId\x12\x14\n" +
	"\x05roles\x18\v \x01(\tR\x05roles\x12\x14\n" +
	"\x05email\x18\f \x01(\tR\x05email\x12\x1a\n" +
	"\busername\x18\r \x01(\tR\busername\x12%\n" +
	"\x0esource_service\x18\x0e \x01(\tR\rsourceService\x12%\n" +
	"\x0etarget_service\x18\x0f \x01(\tR\rtargetService\x12+\n" +
	"\x12user_id_in_context\x18\x10 \x01(\tR\x0fuserIdInContext\"K\n" +
	"\x13GetPublicKeyRequest\x12\x1d\n" +
	"\n" +
	"project_id\x18\x01 \x01(\tR\tprojectId\x12\x15\n" +
	"\x06key_id\x18\x02 \x01(\tR\x05keyId\"\xea\x01\n" +
	"\x14GetPublicKeyResponse\x12$\n" +
	"\x0epublic_key_pem\x18\x01 \x01(\tR\fpublicKeyPem\x12\x1c\n" +
	"\talgorithm\x18\x02 \x01(\tR\talgorithm\x12\x15\n" +
	"\x06key_id\x18\x03 \x01(\tR\x05keyId\x12\x1d\n" +
	"\n" +
	"project_id\x18\x04 \x01(\tR\tprojectId\x12\x1f\n" +
	"\vcache_until\x18\x05 \x01(\x03R\n" +
	"cacheUntil\x127\n" +
	"\vactive_keys\x18\x06 \x03(\v2\x16.auth.v1.PublicKeyInfoR\n" +
	"activeKeys\"\xa8\x01\n" +
	"\rPublicKeyInfo\x12\x15\n" +
	"\x06key_id\x18\x01 \x01(\tR\x05keyId\x12$\n" +
	"\x0epublic_key_pem\x18\x02 \x01(\tR\fpublicKeyPem\x12\x1c\n" +
	"\talgorithm\x18\x03 \x01(\tR\talgorithm\x12\x1d\n" +
	"\n" +
	"expires_at\x18\x04 \x01(\x03R\texpiresAt\x12\x1d\n" +
	"\n" +
	"is_primary\x18\x05 \x01(\bR\tisPrimary\"\x14\n" +
	"\x12HealthCheckRequest\"\xfe\x01\n" +
	"\x13HealthCheckResponse\x12\x16\n" +
	"\x06status\x18\x01 \x01(\tR\x06status\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\x12C\n" +
	"\adetails\x18\x03 \x03(\v2).auth.v1.HealthCheckResponse.DetailsEntryR\adetails\x12\x18\n" +
	"\aversion\x18\x04 \x01(\tR\aversion\x12\x16\n" +
	"\x06uptime\x18\x05 \x01(\x03R\x06uptime\x1a:\n" +
	"\fDetailsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xb4\x02\n" +
	"\x18IssueServiceTokenRequest\x12%\n" +
	"\x0esource_service\x18\x01 \x01(\tR\rsourceService\x12%\n" +
	"\x0etarget_service\x18\x02 \x01(\tR\rtargetService\x12\x17\n" +
	"\auser_id\x18\x03 \x01(\tR\x06userId\x12E\n" +
	"\x06claims\x18\x04 \x03(\v2-.auth.v1.IssueServiceTokenRequest.ClaimsEntryR\x06claims\x12\x10\n" +
	"\x03ttl\x18\x05 \x01(\x03R\x03ttl\x12\x1d\n" +
	"\n" +
	"project_id\x18\x06 \x01(\tR\tprojectId\x1a9\n" +
	"\vClaimsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xac\x01\n" +
	"\x13CreateAPIKeyRequest\x12\x1d\n" +
	"\n" +
	"project_id\x18\x01 \x01(\tR\tprojectId\x12\x17\n" +
	"\auser_id\x18\x02 \x01(\tR\x06userId\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12\x16\n" +
	"\x06scopes\x18\x04 \x03(\tR\x06scopes\x12\x10\n" +
	"\x03ttl\x18\x05 \x01(\x03R\x03ttl\x12\x1f\n" +
	"\vallowed_ips\x18\x06 \x03(\tR\n" +
	"allowedIps\"\x84\x01\n" +
	"\x14CreateAPIKeyResponse\x12\x17\n" +
	"\aapi_key\x18\x01 \x01(\tR\x06apiKey\x12\x15\n" +
	"\x06key_id\x18\x02 \x01(\tR\x05keyId\x12\x1d\n" +
	"\n" +
	"expires_at\x18\x03 \x01(\x03R\texpiresAt\x12\x1d\n" +
	"\n" +
	"created_at\x18\x04 \x01(\x03R\tcreatedAt\"x\n" +
	"\x15ValidateAPIKeyRequest\x12\x17\n" +
	"\aapi_key\x18\x01 \x01(\tR\x06apiKey\x12'\n" +
	"\x0frequired_scopes\x18\x02 \x03(\tR\x0erequiredScopes\x12\x1d\n" +
	"\n" +
	"project_id\x18\x03 \x01(\tR\tprojectId\"\xcf\x02\n" +
	"\x16ValidateAPIKeyResponse\x12\x14\n" +
	"\x05valid\x18\x01 \x01(\bR\x05valid\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x121\n" +
	"\n" +
	"error_code\x18\x03 \x01(\x0e2\x12.auth.v1.ErrorCodeR\terrorCode\x12\x1d\n" +
	"\n" +
	"project_id\x18\x04 \x01(\tR\tprojectId\x12\x17\n" +
	"\auser_id\x18\x05 \x01(\tR\x06userId\x12\x16\n" +
	"\x06scopes\x18\x06 \x03(\tR\x06scopes\x12I\n" +
	"\bmetadata\x18\a \x03(\v2-.auth.v1.ValidateAPIKeyResponse.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"d\n" +
	"\x13RevokeAPIKeyRequest\x12\x15\n" +
	"\x06key_id\x18\x01 \x01(\tR\x05keyId\x12\x17\n" +
	"\aapi_key\x18\x02 \x01(\tR\x06apiKey\x12\x1d\n" +
	"\n" +
	"project_id\x18\x03 \x01(\tR\tprojectId\"F\n" +
	"\x14RevokeAPIKeyResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"}\n" +
	"\x12ListAPIKeysRequest\x12\x1d\n" +
	"\n" +
	"project_id\x18\x01 \x01(\tR\tprojectId\x12\x17\n" +
	"\auser_id\x18\x02 \x01(\tR\x06userId\x12\x12\n" +
	"\x04page\x18\x03 \x01(\x05R\x04page\x12\x1b\n" +
	"\tpage_size\x18\x04 \x01(\x05R\bpageSize\"\x85\x01\n" +
	"\x13ListAPIKeysResponse\x12'\n" +
	"\x04keys\x18\x01 \x03(\v2\x13.auth.v1.APIKeyInfoR\x04keys\x12\x14\n" +
	"\x05total\x18\x02 \x01(\x05R\x05total\x12\x12\n" +
	"\x04page\x18\x03 \x01(\x05R\x04page\x12\x1b\n" +
	"\tpage_size\x18\x04 \x01(\x05R\bpageSize\"\xff\x01\n" +
	"\n" +
	"APIKeyInfo\x12\x15\n" +
	"\x06key_id\x18\x01 \x01(\tR\x05keyId\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x1d\n" +
	"\n" +
	"project_id\x18\x03 \x01(\tR\tprojectId\x12\x17\n" +
	"\auser_id\x18\x04 \x01(\tR\x06userId\x12\x16\n" +
	"\x06scopes\x18\x05 \x03(\tR\x06scopes\x12\x1d\n" +
	"\n" +
	"created_at\x18\x06 \x01(\x03R\tcreatedAt\x12\x1d\n" +
	"\n" +
	"expires_at\x18\a \x01(\x03R\texpiresAt\x12\x16\n" +
	"\x06active\x18\b \x01(\bR\x06active\x12 \n" +
	"\flast_used_at\x18\t \x01(\x03R\n" +
	"lastUsedAt*\x9e\x03\n" +
	"\tErrorCode\x12\x11\n" +
	"\rERROR_UNKNOWN\x10\x00\x12\x17\n" +
	"\x13ERROR_INVALID_TOKEN\x10\x01\x12\x17\n" +
	"\x13ERROR_EXPIRED_TOKEN\x10\x02\x12\x1b\n" +
	"\x17ERROR_INVALID_SIGNATURE\x10\x03\x12\x17\n" +
	"\x13ERROR_TOKEN_REVOKED\x10\x04\x12\x18\n" +
	"\x14ERROR_INVALID_ISSUER\x10\x05\x12\x1a\n" +
	"\x16ERROR_INVALID_AUDIENCE\x10\x06\x12\x17\n" +
	"\x13ERROR_KEY_NOT_FOUND\x10\a\x12\x19\n" +
	"\x15ERROR_INVALID_USER_ID\x10\b\x12\x1f\n" +
	"\x1bERROR_REFRESH_TOKEN_INVALID\x10\t\x12\x1f\n" +
	"\x1bERROR_REFRESH_TOKEN_EXPIRED\x10\n" +
	"\x12\x1d\n" +
	"\x19ERROR_RATE_LIMIT_EXCEEDED\x10\v\x12\x19\n" +
	"\x15ERROR_UNAUTHENTICATED\x10\f\x12\x1c\n" +
	"\x18ERROR_INVALID_PROJECT_ID\x10\r\x12\x12\n" +
	"\x0eERROR_INTERNAL\x10c2\x8d\x06\n" +
	"\n" +
	"JWTService\x12E\n" +
	"\n" +
	"IssueToken\x12\x1a.auth.v1.IssueTokenRequest\x1a\x1b.auth.v1.IssueTokenResponse\x12K\n" +
	"\fRefreshToken\x12\x1c.auth.v1.RefreshTokenRequest\x1a\x1d.auth.v1.RefreshTokenResponse\x12S\n" +
	"\x11IssueServiceToken\x12!.auth.v1.IssueServiceTokenRequest\x1a\x1b.auth.v1.IssueTokenResponse\x12N\n" +
	"\rValidateToken\x12\x1d.auth.v1.ValidateTokenRequest\x1a\x1e.auth.v1.ValidateTokenResponse\x12E\n" +
	"\n" +
	"ParseToken\x12\x1a.auth.v1.ParseTokenRequest\x1a\x1b.auth.v1.ParseTokenResponse\x12N\n" +
	"\rExtractClaims\x12\x1d.auth.v1.ExtractClaimsRequest\x1a\x1e.auth.v1.ExtractClaimsResponse\x12H\n" +
	"\vRevokeToken\x12\x1b.auth.v1.RevokeTokenRequest\x1a\x1c.auth.v1.RevokeTokenResponse\x12N\n" +
	"\rValidateBatch\x12\x1d.auth.v1.ValidateBatchRequest\x1a\x1e.auth.v1.ValidateBatchResponse\x12K\n" +
	"\fGetPublicKey\x12\x1c.auth.v1.GetPublicKeyRequest\x1a\x1d.auth.v1.GetPublicKeyResponse\x12H\n" +
	"\vHealthCheck\x12\x1b.auth.v1.HealthCheckRequest\x1a\x1c.auth.v1.HealthCheckResponse2\xc6\x02\n" +
	"\rAPIKeyService\x12K\n" +
	"\fCreateAPIKey\x12\x1c.auth.v1.CreateAPIKeyRequest\x1a\x1d.auth.v1.CreateAPIKeyResponse\x12Q\n" +
	"\x0eValidateAPIKey\x12\x1e.auth.v1.ValidateAPIKeyRequest\x1a\x1f.auth.v1.ValidateAPIKeyResponse\x12K\n" +
	"\fRevokeAPIKey\x12\x1c.auth.v1.RevokeAPIKeyRequest\x1a\x1d.auth.v1.RevokeAPIKeyResponse\x12H\n" +
	"\vListAPIKeys\x12\x1b.auth.v1.ListAPIKeysRequest\x1a\x1c.auth.v1.ListAPIKeysResponseBOZMgithub.com/kabiroman/octawire-auth-service-go-client/pkg/proto/auth/v1;authv1b\x06proto3"

var (
	file_jwt_proto_rawDescOnce sync.Once
	file_jwt_proto_rawDescData []byte
)

func file_jwt_proto_rawDescGZIP() []byte {
	file_jwt_proto_rawDescOnce.Do(func() {
		file_jwt_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_jwt_proto_rawDesc), len(file_jwt_proto_rawDesc)))
	})
	return file_jwt_proto_rawDescData
}

var file_jwt_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_jwt_proto_msgTypes = make([]protoimpl.MessageInfo, 35)
var file_jwt_proto_goTypes = []any{
	(ErrorCode)(0),                   // 0: auth.v1.ErrorCode
	(*IssueTokenRequest)(nil),        // 1: auth.v1.IssueTokenRequest
	(*IssueTokenResponse)(nil),       // 2: auth.v1.IssueTokenResponse
	(*RefreshTokenRequest)(nil),      // 3: auth.v1.RefreshTokenRequest
	(*RefreshTokenResponse)(nil),     // 4: auth.v1.RefreshTokenResponse
	(*ValidateTokenRequest)(nil),     // 5: auth.v1.ValidateTokenRequest
	(*ValidateTokenResponse)(nil),    // 6: auth.v1.ValidateTokenResponse
	(*ParseTokenRequest)(nil),        // 7: auth.v1.ParseTokenRequest
	(*ParseTokenResponse)(nil),       // 8: auth.v1.ParseTokenResponse
	(*ExtractClaimsRequest)(nil),     // 9: auth.v1.ExtractClaimsRequest
	(*ExtractClaimsResponse)(nil),    // 10: auth.v1.ExtractClaimsResponse
	(*RevokeTokenRequest)(nil),       // 11: auth.v1.RevokeTokenRequest
	(*RevokeTokenResponse)(nil),      // 12: auth.v1.RevokeTokenResponse
	(*ValidateBatchRequest)(nil),     // 13: auth.v1.ValidateBatchRequest
	(*ValidateBatchResponse)(nil),    // 14: auth.v1.ValidateBatchResponse
	(*TokenClaims)(nil),              // 15: auth.v1.TokenClaims
	(*GetPublicKeyRequest)(nil),      // 16: auth.v1.GetPublicKeyRequest
	(*GetPublicKeyResponse)(nil),     // 17: auth.v1.GetPublicKeyResponse
	(*PublicKeyInfo)(nil),            // 18: auth.v1.PublicKeyInfo
	(*HealthCheckRequest)(nil),       // 19: auth.v1.HealthCheckRequest
	(*HealthCheckResponse)(nil),      // 20: auth.v1.HealthCheckResponse
	(*IssueServiceTokenRequest)(nil), // 21: auth.v1.IssueServiceTokenRequest
	(*CreateAPIKeyRequest)(nil),      // 22: auth.v1.CreateAPIKeyRequest
	(*CreateAPIKeyResponse)(nil),     // 23: auth.v1.CreateAPIKeyResponse
	(*ValidateAPIKeyRequest)(nil),    // 24: auth.v1.ValidateAPIKeyRequest
	(*ValidateAPIKeyResponse)(nil),   // 25: auth.v1.ValidateAPIKeyResponse
	(*RevokeAPIKeyRequest)(nil),      // 26: auth.v1.RevokeAPIKeyRequest
	(*RevokeAPIKeyResponse)(nil),     // 27: auth.v1.RevokeAPIKeyResponse
	(*ListAPIKeysRequest)(nil),       // 28: auth.v1.ListAPIKeysRequest
	(*ListAPIKeysResponse)(nil),      // 29: auth.v1.ListAPIKeysResponse
	(*APIKeyInfo)(nil),               // 30: auth.v1.APIKeyInfo
	nil,                              // 31: auth.v1.IssueTokenRequest.ClaimsEntry
	nil,                              // 32: auth.v1.ExtractClaimsResponse.ClaimsEntry
	nil,                              // 33: auth.v1.HealthCheckResponse.DetailsEntry
	nil,                              // 34: auth.v1.IssueServiceTokenRequest.ClaimsEntry
	nil,                              // 35: auth.v1.ValidateAPIKeyResponse.MetadataEntry
}
var file_jwt_proto_depIdxs = []int32{
	31, // 0: auth.v1.IssueTokenRequest.claims:type_name -> auth.v1.IssueTokenRequest.ClaimsEntry
	0,  // 1: auth.v1.ValidateTokenResponse.error_code:type_name -> auth.v1.ErrorCode
	15, // 2: auth.v1.ValidateTokenResponse.claims:type_name -> auth.v1.TokenClaims
	15, // 3: auth.v1.ParseTokenResponse.claims:type_name -> auth.v1.TokenClaims
	32, // 4: auth.v1.ExtractClaimsResponse.claims:type_name -> auth.v1.ExtractClaimsResponse.ClaimsEntry
	6,  // 5: auth.v1.ValidateBatchResponse.results:type_name -> auth.v1.ValidateTokenResponse
	18, // 6: auth.v1.GetPublicKeyResponse.active_keys:type_name -> auth.v1.PublicKeyInfo
	33, // 7: auth.v1.HealthCheckResponse.details:type_name -> auth.v1.HealthCheckResponse.DetailsEntry
	34, // 8: auth.v1.IssueServiceTokenRequest.claims:type_name -> auth.v1.IssueServiceTokenRequest.ClaimsEntry
	0,  // 9: auth.v1.ValidateAPIKeyResponse.error_code:type_name -> auth.v1.ErrorCode
	35, // 10: auth.v1.ValidateAPIKeyResponse.metadata:type_name -> auth.v1.ValidateAPIKeyResponse.MetadataEntry
	30, // 11: auth.v1.ListAPIKeysResponse.keys:type_name -> auth.v1.APIKeyInfo
	1,  // 12: auth.v1.JWTService.IssueToken:input_type -> auth.v1.IssueTokenRequest
	3,  // 13: auth.v1.JWTService.RefreshToken:input_type -> auth.v1.RefreshTokenRequest
	21, // 14: auth.v1.JWTService.IssueServiceToken:input_type -> auth.v1.IssueServiceTokenRequest
	5,  // 15: auth.v1.JWTService.ValidateToken:input_type -> auth.v1.ValidateTokenRequest
	7,  // 16: auth.v1.JWTService.ParseToken:input_type -> auth.v1.ParseTokenRequest
	9,  // 17: auth.v1.JWTService.ExtractClaims:input_type -> auth.v1.ExtractClaimsRequest
	11, // 18: auth.v1.JWTService.RevokeToken:input_type -> auth.v1.RevokeTokenRequest
	13, // 19: auth.v1.JWTService.ValidateBatch:input_type -> auth.v1.ValidateBatchRequest
	16, // 20: auth.v1.JWTService.GetPublicKey:input_type -> auth.v1.GetPublicKeyRequest
	19, // 21: auth.v1.JWTService.HealthCheck:input_type -> auth.v1.HealthCheckRequest
	22, // 22: auth.v1.APIKeyService.CreateAPIKey:input_type -> auth.v1.CreateAPIKeyRequest
	24, // 23: auth.v1.APIKeyService.ValidateAPIKey:input_type -> auth.v1.ValidateAPIKeyRequest
	26, // 24: auth.v1.APIKeyService.RevokeAPIKey:input_type -> auth.v1.RevokeAPIKeyRequest
	28, // 25: auth.v1.APIKeyService.ListAPIKeys:input_type -> auth.v1.ListAPIKeysRequest
	2,  // 26: auth.v1.JWTService.IssueToken:output_type -> auth.v1.IssueTokenResponse
	4,  // 27: auth.v1.JWTService.RefreshToken:output_type -> auth.v1.RefreshTokenResponse
	2,  // 28: auth.v1.JWTService.IssueServiceToken:output_type -> auth.v1.IssueTokenResponse
	6,  // 29: auth.v1.JWTService.ValidateToken:output_type -> auth.v1.ValidateTokenResponse
	8,  // 30: auth.v1.JWTService.ParseToken:output_type -> auth.v1.ParseTokenResponse
	10, // 31: auth.v1.JWTService.ExtractClaims:output_type -> auth.v1.ExtractClaimsResponse
	12, // 32: auth.v1.JWTService.RevokeToken:output_type -> auth.v1.RevokeTokenResponse
	14, // 33: auth.v1.JWTService.ValidateBatch:output_type -> auth.v1.ValidateBatchResponse
	17, // 34: auth.v1.JWTService.GetPublicKey:output_type -> auth.v1.GetPublicKeyResponse
	20, // 35: auth.v1.JWTService.HealthCheck:output_type -> auth.v1.HealthCheckResponse
	23, // 36: auth.v1.APIKeyService.CreateAPIKey:output_type -> auth.v1.CreateAPIKeyResponse
	25, // 37: auth.v1.APIKeyService.ValidateAPIKey:output_type -> auth.v1.ValidateAPIKeyResponse
	27, // 38: auth.v1.APIKeyService.RevokeAPIKey:output_type -> auth.v1.RevokeAPIKeyResponse
	29, // 39: auth.v1.APIKeyService.ListAPIKeys:output_type -> auth.v1.ListAPIKeysResponse
	26, // [26:40] is the sub-list for method output_type
	12, // [12:26] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_jwt_proto_init() }
func file_jwt_proto_init() {
	if File_jwt_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_jwt_proto_rawDesc), len(file_jwt_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   35,
			NumExtensions: 0,
			NumServices:   2,
		},
		GoTypes:           file_jwt_proto_goTypes,
		DependencyIndexes: file_jwt_proto_depIdxs,
		EnumInfos:         file_jwt_proto_enumTypes,
		MessageInfos:      file_jwt_proto_msgTypes,
	}.Build()
	File_jwt_proto = out.File
	file_jwt_proto_goTypes = nil
	file_jwt_proto_depIdxs = nil
}
