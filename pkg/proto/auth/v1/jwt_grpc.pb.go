// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: jwt.proto

package authv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	JWTService_IssueToken_FullMethodName        = "/auth.v1.JWTService/IssueToken"
	JWTService_RefreshToken_FullMethodName      = "/auth.v1.JWTService/RefreshToken"
	JWTService_IssueServiceToken_FullMethodName = "/auth.v1.JWTService/IssueServiceToken"
	JWTService_ValidateToken_FullMethodName     = "/auth.v1.JWTService/ValidateToken"
	JWTService_ParseToken_FullMethodName        = "/auth.v1.JWTService/ParseToken"
	JWTService_ExtractClaims_FullMethodName     = "/auth.v1.JWTService/ExtractClaims"
	JWTService_RevokeToken_FullMethodName       = "/auth.v1.JWTService/RevokeToken"
	JWTService_ValidateBatch_FullMethodName     = "/auth.v1.JWTService/ValidateBatch"
	JWTService_GetPublicKey_FullMethodName      = "/auth.v1.JWTService/GetPublicKey"
	JWTService_HealthCheck_FullMethodName       = "/auth.v1.JWTService/HealthCheck"
)

// JWTServiceClient is the client API for JWTService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// JWTService - управление JWT токенами
type JWTServiceClient interface {
	// Пользовательские токены
	// IssueToken - выдача нового JWT токена (access + refresh)
	IssueToken(ctx context.Context, in *IssueTokenRequest, opts ...grpc.CallOption) (*IssueTokenResponse, error)
	// RefreshToken - обновление токена (выдача нового токена на основе refresh token)
	RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error)
	// Сервисные токены
	// IssueServiceToken - выдача межсервисного JWT токена
	IssueServiceToken(ctx context.Context, in *IssueServiceTokenRequest, opts ...grpc.CallOption) (*IssueTokenResponse, error)
	// Валидация и утилиты
	// ValidateToken - валидация токена (проверка подписи, срока действия, blacklist)
	ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error)
	// ParseToken - парсинг токена без валидации (извлечение claims)
	ParseToken(ctx context.Context, in *ParseTokenRequest, opts ...grpc.CallOption) (*ParseTokenResponse, error)
	// ExtractClaims - извлечение claims из токена (без валидации)
	ExtractClaims(ctx context.Context, in *ExtractClaimsRequest, opts ...grpc.CallOption) (*ExtractClaimsResponse, error)
	// RevokeToken - отзыв токена (добавление в blacklist)
	RevokeToken(ctx context.Context, in *RevokeTokenRequest, opts ...grpc.CallOption) (*RevokeTokenResponse, error)
	// ValidateBatch - пакетная валидация токенов
	ValidateBatch(ctx context.Context, in *ValidateBatchRequest, opts ...grpc.CallOption) (*ValidateBatchResponse, error)
	// GetPublicKey - получение публичного ключа для проекта (для локальной валидации)
	// Позволяет другим сервисам получать публичные ключи для локальной проверки подписи
	GetPublicKey(ctx context.Context, in *GetPublicKeyRequest, opts ...grpc.CallOption) (*GetPublicKeyResponse, error)
	// HealthCheck - проверка здоровья сервиса
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type jWTServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewJWTServiceClient(cc grpc.ClientConnInterface) JWTServiceClient {
	return &jWTServiceClient{cc}
}

func (c *jWTServiceClient) IssueToken(ctx context.Context, in *IssueTokenRequest, opts ...grpc.CallOption) (*IssueTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IssueTokenResponse)
	err := c.cc.Invoke(ctx, JWTService_IssueToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTServiceClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshTokenResponse)
	err := c.cc.Invoke(ctx, JWTService_RefreshToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTServiceClient) IssueServiceToken(ctx context.Context, in *IssueServiceTokenRequest, opts ...grpc.CallOption) (*IssueTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IssueTokenResponse)
	err := c.cc.Invoke(ctx, JWTService_IssueServiceToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTServiceClient) ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateTokenResponse)
	err := c.cc.Invoke(ctx, JWTService_ValidateToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTServiceClient) ParseToken(ctx context.Context, in *ParseTokenRequest, opts ...grpc.CallOption) (*ParseTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ParseTokenResponse)
	err := c.cc.Invoke(ctx, JWTService_ParseToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTServiceClient) ExtractClaims(ctx context.Context, in *ExtractClaimsRequest, opts ...grpc.CallOption) (*ExtractClaimsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExtractClaimsResponse)
	err := c.cc.Invoke(ctx, JWTService_ExtractClaims_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTServiceClient) RevokeToken(ctx context.Context, in *RevokeTokenRequest, opts ...grpc.CallOption) (*RevokeTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeTokenResponse)
	err := c.cc.Invoke(ctx, JWTService_RevokeToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTServiceClient) ValidateBatch(ctx context.Context, in *ValidateBatchRequest, opts ...grpc.CallOption) (*ValidateBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateBatchResponse)
	err := c.cc.Invoke(ctx, JWTService_ValidateBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTServiceClient) GetPublicKey(ctx context.Context, in *GetPublicKeyRequest, opts ...grpc.CallOption) (*GetPublicKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPublicKeyResponse)
	err := c.cc.Invoke(ctx, JWTService_GetPublicKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, JWTService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JWTServiceServer is the server API for JWTService service.
// All implementations must embed UnimplementedJWTServiceServer
// for forward compatibility.
//
// JWTService - управление JWT токенами
type JWTServiceServer interface {
	// Пользовательские токены
	// IssueToken - выдача нового JWT токена (access + refresh)
	IssueToken(context.Context, *IssueTokenRequest) (*IssueTokenResponse, error)
	// RefreshToken - обновление токена (выдача нового токена на основе refresh token)
	RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error)
	// Сервисные токены
	// IssueServiceToken - выдача межсервисного JWT токена
	IssueServiceToken(context.Context, *IssueServiceTokenRequest) (*IssueTokenResponse, error)
	// Валидация и утилиты
	// ValidateToken - валидация токена (проверка подписи, срока действия, blacklist)
	ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error)
	// ParseToken - парсинг токена без валидации (извлечение claims)
	ParseToken(context.Context, *ParseTokenRequest) (*ParseTokenResponse, error)
	// ExtractClaims - извлечение claims из токена (без валидации)
	ExtractClaims(context.Context, *ExtractClaimsRequest) (*ExtractClaimsResponse, error)
	// RevokeToken - отзыв токена (добавление в blacklist)
	RevokeToken(context.Context, *RevokeTokenRequest) (*RevokeTokenResponse, error)
	// ValidateBatch - пакетная валидация токенов
	ValidateBatch(context.Context, *ValidateBatchRequest) (*ValidateBatchResponse, error)
	// GetPublicKey - получение публичного ключа для проекта (для локальной валидации)
	// Позволяет другим сервисам получать публичные ключи для локальной проверки подписи
	GetPublicKey(context.Context, *GetPublicKeyRequest) (*GetPublicKeyResponse, error)
	// HealthCheck - проверка здоровья сервиса
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	mustEmbedUnimplementedJWTServiceServer()
}

// UnimplementedJWTServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedJWTServiceServer struct{}

func (UnimplementedJWTServiceServer) IssueToken(context.Context, *IssueTokenRequest) (*IssueTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IssueToken not implemented")
}
func (UnimplementedJWTServiceServer) RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RefreshToken not implemented")
}
func (UnimplementedJWTServiceServer) IssueServiceToken(context.Context, *IssueServiceTokenRequest) (*IssueTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IssueServiceToken not implemented")
}
func (UnimplementedJWTServiceServer) ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateToken not implemented")
}
func (UnimplementedJWTServiceServer) ParseToken(context.Context, *ParseTokenRequest) (*ParseTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ParseToken not implemented")
}
func (UnimplementedJWTServiceServer) ExtractClaims(context.Context, *ExtractClaimsRequest) (*ExtractClaimsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExtractClaims not implemented")
}
func (UnimplementedJWTServiceServer) RevokeToken(context.Context, *RevokeTokenRequest) (*RevokeTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeToken not implemented")
}
func (UnimplementedJWTServiceServer) ValidateBatch(context.Context, *ValidateBatchRequest) (*ValidateBatchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateBatch not implemented")
}
func (UnimplementedJWTServiceServer) GetPublicKey(context.Context, *GetPublicKeyRequest) (*GetPublicKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPublicKey not implemented")
}
func (UnimplementedJWTServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedJWTServiceServer) mustEmbedUnimplementedJWTServiceServer() {}
func (UnimplementedJWTServiceServer) testEmbeddedByValue()                    {}

// UnsafeJWTServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JWTServiceServer will
// result in compilation errors.
type UnsafeJWTServiceServer interface {
	mustEmbedUnimplementedJWTServiceServer()
}

func RegisterJWTServiceServer(s grpc.ServiceRegistrar, srv JWTServiceServer) {
	// If the following call panics, it indicates UnimplementedJWTServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&JWTService_ServiceDesc, srv)
}

func _JWTService_IssueToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IssueTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTServiceServer).IssueToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JWTService_IssueToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTServiceServer).IssueToken(ctx, req.(*IssueTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTServiceServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JWTService_RefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTServiceServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTService_IssueServiceToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IssueServiceTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTServiceServer).IssueServiceToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JWTService_IssueServiceToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTServiceServer).IssueServiceToken(ctx, req.(*IssueServiceTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTService_ValidateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTServiceServer).ValidateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JWTService_ValidateToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTServiceServer).ValidateToken(ctx, req.(*ValidateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTService_ParseToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParseTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTServiceServer).ParseToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JWTService_ParseToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTServiceServer).ParseToken(ctx, req.(*ParseTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTService_ExtractClaims_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExtractClaimsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTServiceServer).ExtractClaims(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JWTService_ExtractClaims_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTServiceServer).ExtractClaims(ctx, req.(*ExtractClaimsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTService_RevokeToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTServiceServer).RevokeToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JWTService_RevokeToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTServiceServer).RevokeToken(ctx, req.(*RevokeTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTService_ValidateBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTServiceServer).ValidateBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JWTService_ValidateBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTServiceServer).ValidateBatch(ctx, req.(*ValidateBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTService_GetPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPublicKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTServiceServer).GetPublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JWTService_GetPublicKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTServiceServer).GetPublicKey(ctx, req.(*GetPublicKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JWTService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// JWTService_ServiceDesc is the grpc.ServiceDesc for JWTService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JWTService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.v1.JWTService",
	HandlerType: (*JWTServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IssueToken",
			Handler:    _JWTService_IssueToken_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _JWTService_RefreshToken_Handler,
		},
		{
			MethodName: "IssueServiceToken",
			Handler:    _JWTService_IssueServiceToken_Handler,
		},
		{
			MethodName: "ValidateToken",
			Handler:    _JWTService_ValidateToken_Handler,
		},
		{
			MethodName: "ParseToken",
			Handler:    _JWTService_ParseToken_Handler,
		},
		{
			MethodName: "ExtractClaims",
			Handler:    _JWTService_ExtractClaims_Handler,
		},
		{
			MethodName: "RevokeToken",
			Handler:    _JWTService_RevokeToken_Handler,
		},
		{
			MethodName: "ValidateBatch",
			Handler:    _JWTService_ValidateBatch_Handler,
		},
		{
			MethodName: "GetPublicKey",
			Handler:    _JWTService_GetPublicKey_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _JWTService_HealthCheck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "jwt.proto",
}

const (
	APIKeyService_CreateAPIKey_FullMethodName   = "/auth.v1.APIKeyService/CreateAPIKey"
	APIKeyService_ValidateAPIKey_FullMethodName = "/auth.v1.APIKeyService/ValidateAPIKey"
	APIKeyService_RevokeAPIKey_FullMethodName   = "/auth.v1.APIKeyService/RevokeAPIKey"
	APIKeyService_ListAPIKeys_FullMethodName    = "/auth.v1.APIKeyService/ListAPIKeys"
)

// APIKeyServiceClient is the client API for APIKeyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// APIKeyService - управление API ключами
type APIKeyServiceClient interface {
	// CreateAPIKey - создание нового API ключа
	CreateAPIKey(ctx context.Context, in *CreateAPIKeyRequest, opts ...grpc.CallOption) (*CreateAPIKeyResponse, error)
	// ValidateAPIKey - валидация API ключа
	ValidateAPIKey(ctx context.Context, in *ValidateAPIKeyRequest, opts ...grpc.CallOption) (*ValidateAPIKeyResponse, error)
	// RevokeAPIKey - отзыв API ключа
	RevokeAPIKey(ctx context.Context, in *RevokeAPIKeyRequest, opts ...grpc.CallOption) (*RevokeAPIKeyResponse, error)
	// ListAPIKeys - список API ключей для проекта/пользователя
	ListAPIKeys(ctx context.Context, in *ListAPIKeysRequest, opts ...grpc.CallOption) (*ListAPIKeysResponse, error)
}

type aPIKeyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAPIKeyServiceClient(cc grpc.ClientConnInterface) APIKeyServiceClient {
	return &aPIKeyServiceClient{cc}
}

func (c *aPIKeyServiceClient) CreateAPIKey(ctx context.Context, in *CreateAPIKeyRequest, opts ...grpc.CallOption) (*CreateAPIKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAPIKeyResponse)
	err := c.cc.Invoke(ctx, APIKeyService_CreateAPIKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIKeyServiceClient) ValidateAPIKey(ctx context.Context, in *ValidateAPIKeyRequest, opts ...grpc.CallOption) (*ValidateAPIKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateAPIKeyResponse)
	err := c.cc.Invoke(ctx, APIKeyService_ValidateAPIKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIKeyServiceClient) RevokeAPIKey(ctx context.Context, in *RevokeAPIKeyRequest, opts ...grpc.CallOption) (*RevokeAPIKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeAPIKeyResponse)
	err := c.cc.Invoke(ctx, APIKeyService_RevokeAPIKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIKeyServiceClient) ListAPIKeys(ctx context.Context, in *ListAPIKeysRequest, opts ...grpc.CallOption) (*ListAPIKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAPIKeysResponse)
	err := c.cc.Invoke(ctx, APIKeyService_ListAPIKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// APIKeyServiceServer is the server API for APIKeyService service.
// All implementations must embed UnimplementedAPIKeyServiceServer
// for forward compatibility.
//
// APIKeyService - управление API ключами
type APIKeyServiceServer interface {
	// CreateAPIKey - создание нового API ключа
	CreateAPIKey(context.Context, *CreateAPIKeyRequest) (*CreateAPIKeyResponse, error)
	// ValidateAPIKey - валидация API ключа
	ValidateAPIKey(context.Context, *ValidateAPIKeyRequest) (*ValidateAPIKeyResponse, error)
	// RevokeAPIKey - отзыв API ключа
	RevokeAPIKey(context.Context, *RevokeAPIKeyRequest) (*RevokeAPIKeyResponse, error)
	// ListAPIKeys - список API ключей для проекта/пользователя
	ListAPIKeys(context.Context, *ListAPIKeysRequest) (*ListAPIKeysResponse, error)
	mustEmbedUnimplementedAPIKeyServiceServer()
}

// UnimplementedAPIKeyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAPIKeyServiceServer struct{}

func (UnimplementedAPIKeyServiceServer) CreateAPIKey(context.Context, *CreateAPIKeyRequest) (*CreateAPIKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateAPIKey not implemented")
}
func (UnimplementedAPIKeyServiceServer) ValidateAPIKey(context.Context, *ValidateAPIKeyRequest) (*ValidateAPIKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateAPIKey not implemented")
}
func (UnimplementedAPIKeyServiceServer) RevokeAPIKey(context.Context, *RevokeAPIKeyRequest) (*RevokeAPIKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeAPIKey not implemented")
}
func (UnimplementedAPIKeyServiceServer) ListAPIKeys(context.Context, *ListAPIKeysRequest) (*ListAPIKeysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListAPIKeys not implemented")
}
func (UnimplementedAPIKeyServiceServer) mustEmbedUnimplementedAPIKeyServiceServer() {}
func (UnimplementedAPIKeyServiceServer) testEmbeddedByValue()                       {}

// UnsafeAPIKeyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to APIKeyServiceServer will
// result in compilation errors.
type UnsafeAPIKeyServiceServer interface {
	mustEmbedUnimplementedAPIKeyServiceServer()
}

func RegisterAPIKeyServiceServer(s grpc.ServiceRegistrar, srv APIKeyServiceServer) {
	// If the following call panics, it indicates UnimplementedAPIKeyServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&APIKeyService_ServiceDesc, srv)
}

func _APIKeyService_CreateAPIKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAPIKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIKeyServiceServer).CreateAPIKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: APIKeyService_CreateAPIKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIKeyServiceServer).CreateAPIKey(ctx, req.(*CreateAPIKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _APIKeyService_ValidateAPIKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateAPIKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIKeyServiceServer).ValidateAPIKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: APIKeyService_ValidateAPIKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIKeyServiceServer).ValidateAPIKey(ctx, req.(*ValidateAPIKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _APIKeyService_RevokeAPIKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeAPIKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIKeyServiceServer).RevokeAPIKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: APIKeyService_RevokeAPIKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIKeyServiceServer).RevokeAPIKey(ctx, req.(*RevokeAPIKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _APIKeyService_ListAPIKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAPIKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIKeyServiceServer).ListAPIKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: APIKeyService_ListAPIKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIKeyServiceServer).ListAPIKeys(ctx, req.(*ListAPIKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// APIKeyService_ServiceDesc is the grpc.ServiceDesc for APIKeyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var APIKeyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.v1.APIKeyService",
	HandlerType: (*APIKeyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAPIKey",
			Handler:    _APIKeyService_CreateAPIKey_Handler,
		},
		{
			MethodName: "ValidateAPIKey",
			Handler:    _APIKeyService_ValidateAPIKey_Handler,
		},
		{
			MethodName: "RevokeAPIKey",
			Handler:    _APIKeyService_RevokeAPIKey_Handler,
		},
		{
			MethodName: "ListAPIKeys",
			Handler:    _APIKeyService_ListAPIKeys_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "jwt.proto",
}
